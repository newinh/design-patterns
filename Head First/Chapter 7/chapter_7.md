# Ch 7. Adapter Pattern & Facade Pattern

**어댑터 패턴 정의**
한 클래스의 인터페이스를 클라이언트에서 사용하고자 하는 다른 인터페이스로 변환합니다. 어댑터를 이용하면 인터페이스 호환성 문제때문에 같이 쓸 수 없는 클래스들을 연결해서 쓸 수 있습니다.

1. 클라이언트에서 타겟 인터페이스를 사용하여 메소드를 호출함으로써 어댑터에 요청을 합니다.
2. 어댑터에서는 어댑티 인터페이스를 사용하여 그 요청을 어댑티에 대한 (하나 이상으) 메소드 호출로 변환합니다.
3. 클라이언트에서는 호출결과를 받긴 하지만 중간에 어댑터가 껴 있는지는 전혀알지못합니다.

어댑티를 새로 바뀐 인터페이스로 감쌀때는 **구성(Composition)** 을 사용합니다.

### 객체 어댑터와 클래스 어댑터
객체 어댑터: 구성

클래스 어댑터: 상속

을 이용하여 어댑티를 적응.

| | |
|-| -|
decorator   | 인터페이스는 바꾸지 않고 책임(기능)만 추가
   adpater  | 한 인터페이스를 다른 인터페이스로 변환
   facade   | 인터페이스를 간단하게 바꿈


**퍼사드 패턴의 정의**

어떤 서브시스템의 일련의 인터페이스에 대한 통합된 인터페이스를 제공합니다. 퍼사드에서 고수준의 인터페읻스를 정의하기 때문에 서브시스템을 쉽게 사용할 수 있습니다.

**디자인 원칙**

최소 지식 원칙(Principle of Least Knowledge) - 정말 친한 친구하고만 얘기하라.
- 데메테르의 법칙 (Law of Demeter)
- 다른 메소드를 호출해서 리턴 받은 객체의 메소드를 호출하는 것도 바람직하지 않다.



친구는 만들지 않으면서 다른 객체에 영향력을 행사하는 방법
* 객체자제
* 메소드에 매개변수로 전달된 객체
* 그 모소드에서 생성하거나 인스턴스를 만든 객체
* 그 객체에 속하는 구성요소

```java
public class Car { 
    Engine engine;  // 구성요소
    public Car() {

    }

    public void start(Key key) {
        Doors doors = new Doors(); // 생성한 객체
        boolean authorized = key.turns();  // 매개변수로 전달된 객체
        if (authorized) {
            engine.start();  // 객체의 구성요소의 메소드
            updatedDashboardDisplay();  // 객체 내에 있는 메소드
            doors.lock();  // 직접 생성한 인스턴스의 메소드
        }
    }

    public void updatedDashboardDisplay() {

    }
}

```



